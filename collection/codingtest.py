##################################################################################################################################
##################################################################################################################################
#코테잘푸는법######################################################################################################################
##################################################################################################################################
##################################################################################################################################
#시간10%이상 문제 분석에 집중
    #시간복잡도체크 
        #제한시간
        #데이터크기
    #샘플예제
        #손으로풀어보기
    #반례찾기

##################################################################################################################################
##################################################################################################################################
#백준문제풀이INPUT함수#############################################################################################################
##################################################################################################################################
##################################################################################################################################
import sys
input = sys.stdin.readline
n = int(input())
list = list(map(int, input().split()))

##################################################################################################################################
##################################################################################################################################
#2.자료구조#######################################################################################################################
##################################################################################################################################
##################################################################################################################################
#리스트
#MAP
#집합
#스택(DFS)
#큐(BFS)
#우선순위큐
###################
###################
#리스트############
###################
###################
#리스트 배열을 문자열로 바꾸기
a = []
string = ''.join(a)

#리스트 요소값 곱하기1
from functools import reduce
reduce(lambda x,y : x*y, [1,2,3,4,5])

#리스트 요소값 곱하기2
from math import prod
prod([1,2,3,4,5])

#리스트 인덱스, 원소 같이 출력
for i, letter in enumerate(['A', 'B', 'C'], start=1):
    print(i, letter)
'''1 A
2 B
3 C'''

# 리스트 인덱스
listA = [1,2,3,4,5]
print(listA[1:4])

#리스트 n개로 분할하기
def list_chuck(arr, n):
    return [arr[i: i + n] for i in range(0, len(arr), n)]
array = [1, 2, 3, 4, 5, 6, 7, 8]
result_array = list_chuck(array, 3)
print(result_array)        # [[1, 2, 3], [4, 5, 6], [7, 8]]

###################
###################
#MAP###############
###################
###################
#Key, Value 쌍 얻기(items)
answer = [k for k, v in dic.items() if v == 1] 

#Key 리스트 만들기(keys)
a = {'name': 'pey', 'phone': '0119993323', 'birth': '1118'}
a.keys()
dict_keys(['name', 'phone', 'birth']) #a.keys()는 딕셔너리 a의 Key만을 모아서 dict_keys 객체를 돌려준다.

#Value 리스트 만들기(values)
a.values()
dict_values(['pey', '0119993323', '1118'])

#value로 키 찾기
[k for k, v in dictP.items() if v == 1]

#딕셔너리안에 키 값 있는지 찾기
if val in dictP:

#딕셔너리 컨프리헨션
d = {e:[] for e in set(genres)}
d[e[0]].append([e[1] , e[2]])

###################
###################
#집합자료형########
###################
################### 
# 중복없음, 순서없음
s1 = set([1,2,3,4,5,6])
s2 = set([4,5,6,7,8,9])
s3 = s1 & s2
print(s3)   #result : {4,5,6}
s3 = s1 | s2
print(s3)   #result : {1, 2, 3, 4, 5, 6, 7, 8, 9}
s3 = s1 - s2
print(s3)   #result : {1, 2, 3}
s3 = s2 - s1
print(s3)   #result : {8, 9, 7}

###################
###################
#스택##############
###################
###################
#(DFS -> 재귀함수)
stack.append(data)
stack.pop()
stack[-1] #top위치에 있는 데이터를 단순 확인

###################
###################
#큐################
###################
###################
# (BFS) 주로 deque로 사용
from collections import deque
d = deque()
d.appendleft(0) #왼쪽에 데이터 삽입
d.append(6) #오른쪽에 데이터삽입
d.popleft() #왼쪽 데이터 지우기
d.pop() #오른쪽 데이터 지우기

###################
###################
#우선순위큐#########
###################
###################
# heap사용 (리스트에서 최소원소 추출하는 자료구조)
# 그리디 알고리즘에서 주로사용
import heapq
heap = []
heapq.heappush(heap, 50)
heapq.heappush(heap, 10)
heapq.heappush(heap, 20)
print(heap)

#heappop 함수는 가장 작은 원소를 힙에서 제거함과 동시에 그를 결괏값으로 리턴한다.
result = heapq.heappop(heap)
print(result)
print(heap)

##################################################################################################################################
##################################################################################################################################
#3.알고리즘#######################################################################################################################
##################################################################################################################################
##################################################################################################################################
#정렬알고리즘
#DFS, BFS, 이진탐색
#정수론 
##################################################################################################################################
##################################################################################################################################
#정렬알고리즘#######################################################################################################################
##################################################################################################################################
##################################################################################################################################
#리스트 거꾸로뒤집음
a = []
a.reverse() 

#기본값 오름차순 정렬
a = [1, 10, 5, 7, 6]
a.sort(reverse=True)

#새로운 그릇에 담고 정렬
x = [1 ,11, 2, 3]
y = sorted(x)

##################################################################################################################################
##################################################################################################################################
#DFS, BFS#######################################################################################################################
##################################################################################################################################
##################################################################################################################################
from collections import deque

N, M, Start = map(int, input().split())
A = [[] for _ in range(N + 1)]
for _ in range(M):
    s, e = map(int, input().split())
    A[s].append(e)  # 양방향 에지이므로 양쪽에 에지를 더하기
    A[e].append(s)
for i in range(N + 1):
    A[i].sort()  # 번호가 작은 노드 부터 방문하기 위해 정렬하기
visited = [False] * (N + 1)


def DFS(v):
    print(v, end=' ')
    visited[v] = True
    for i in A[v]:
        if not visited[i]:
            DFS(i)


DFS(Start)

visited = [False] * (N + 1)  # 리스트 초기화


def BFS(v):
    queue = deque()
    queue.append(v)
    visited[v] = True
    while queue:
        now_Node = queue.popleft()
        print(now_Node, end=' ')
        for i in A[now_Node]:
            if not visited[i]:
                visited[i] = True
                queue.append(i)


print()
BFS(Start)

##################################################################################################################################
##################################################################################################################################
#이진탐색#######################################################################################################################
##################################################################################################################################
##################################################################################################################################
N = int(input())
A = list(map(int, input().split()))
A.sort()
M = int(input())
target_list = list(map(int, input().split()))
for i in range(M):
    find = False
    target = target_list[i]
    # 이진탐색 시작
    start = 0
    end = len(A) - 1
    while start <= end:
        midi = int((start + end) / 2)
        midv = A[midi]
        if midv > target:
            end = midi - 1
        elif midv < target:
            start = midi + 1
        else:
            find = True
            break
    if find:
        print(1)
    else:
        print(0)

##################################################################################################################################
##################################################################################################################################
#소수판별#######################################################################################################################
##################################################################################################################################
##################################################################################################################################
import math
M, N = map(int, input().split())
A = [0] * (N + 1)
for i in range(2, N + 1):
    A[i] = i
for i in range(2, int(math.sqrt(N)) + 1):  # 제곱근까지만 수행
    if A[i] == 0:
        continue
    for j in range(i + i, N + 1, i):  # 배수 지우기
        A[j] = 0
for i in range(M, N + 1):
    if A[i] != 0:
        print(A[i])

###################
###################
#펠린드롬 수에서 최솟값 찾기
###################
###################
#펠린드롬  : 숫자순서 뒤집은 수가 일치하는 수
import math
N = int(input())
A = [0] * (10000001)
for i in range(2, len(A)):
    A[i] = i
for i in range(2, int(math.sqrt(len(A)) + 1)):  # 제곱근까지만 수행
    if A[i] == 0:
        continue
    for j in range(i + i, len(A), i):  # 배수 지우기
        A[j] = 0

def isPalindrome(target):  # 펠린드롬 수 판별 함수
    temp = list(str(target))
    s = 0
    e = len(temp) - 1
    while (s < e):
        if temp[s] != temp[e]:
            return False
        s += 1
        e -= 1
    return True

i = N
while True:  # N부터 1씩 증가시키면서 소수와 팰림드롬 수가 맞는지 판별
    if A[i] != 0:
        result = A[i]
        if (isPalindrome(result)):
            print(result)
            break
    i += 1

###################
###################
#오일러피##############
###################
###################
# 1부터 N까지 범위에서 N과 서로소인 자연수의 개수
import math
N = int(input())
result = N
for p in range(2, int(math.sqrt(N)) + 1):  # 제곱근까지만 진행
    if N % p == 0:  # p가 소인수인지 확인
        result -= result / p  # 결괏값 업데이트
        while N % p == 0:  # 2의 7승*11이라면 2의 7승을 없애고 11만 남김
            N /= p
if N > 1:  # 반복문에서 제곱근까지만 탐색했으므로 1개의 소인수가 누락되는 케이스 처리
    result -= result / N
print(int(result))

###################
###################
#유클리드호제법#####
###################
###################
# 두수의 최대 공약수를 구하는 알고리즘
#최소공배수
def gcd(a, b):
    if b == 0:
        return a
    else:
        return gcd(b, a % b)

t = int(input())
for i in range(t):
    a, b = map(int, input().split())
    result = a * b / gcd(a, b)
    print(int(result))

#최대공약수
def gcd(a, b):
    if b == 0:
        return a
    else:
        return gcd(b, a % b)

a, b = map(int, input().split())
result = gcd(a, b)
while result > 0:
    print(1, end='')
    result -= 1

#유클리드호제법
N = int(input())
A = [[] for _ in range(N)]
visited = [False] * (N)
D = [0] * (N)
lcm = 1

def gcd(a, b):
    if b == 0:
        return a
    else:
        return gcd(b, a % b)

def DFS(v):
    visited[v] = True
    for i in A[v]:
        next = i[0]
        if not visited[next]:
            D[next] = D[v] * i[2] // i[1]
            DFS(next)

for i in range(N - 1):
    a, b, p, q = map(int, input().split())
    A[a].append((b, p, q))
    A[b].append((a, q, p))
    lcm *= (p * q // gcd(p, q))

D[0] = lcm
DFS(0)
mgcd = D[0]
for i in range(1, N):
    mgcd = gcd(mgcd, D[i])
for i in range(N):
    print(int(D[i] // mgcd), end=' ')

##################################################################################################################################
##################################################################################################################################
#그래프############################################################################################################################
##################################################################################################################################
##################################################################################################################################

###################
###################
#유니온파인드#######
###################
###################
# 그래프의 사이클이 생성되는지 판별하는 알고리즘 
import sys
input = sys.stdin.readline
sys.setrecursionlimit(100000)
N, M = map(int, input().split())
parent = [0] * (N + 1)


def find(a):
    if a == parent[a]:
        return a
    else:
        parent[a] = find(parent[a])  # 재귀 형태로 구현 -> 경로 압축 부분
        return parent[a]


def union(a, b):
    a = find(a)
    b = find(b)
    if a != b:
        parent[b] = a


def checkSame(a, b):
    a = find(a)
    b = find(b)
    if a == b:
        return True
    return False


for i in range(0, N + 1):
    parent[i] = i

for i in range(M):
    question, a, b = map(int, input().split())
    if question == 0:
        union(a, b)
    else:
        if checkSame(a, b):
            print("YES")
        else:
            print("NO")

###################
###################
#위상정렬###########
###################
###################
# 사이클이없는 방향그래프에서 노드 순서를 찾는 알고리즘
from collections import deque
N, M = map(int, input().split())
A = [[] for _ in range(N + 1)]
indegree = [0] * (N + 1)  # 진입차수 배열

for i in range(M):
    S, E = map(int, input().split())
    A[S].append(E)
    indegree[E] += 1  # 집입차수 데이터 저장

queue = deque()
for i in range(1, N + 1):
    if indegree[i] == 0:
        queue.append(i)

while queue:  # 위상정렬 수행
    now = queue.popleft()
    print(now, end=' ')
    for next in A[now]:
        indegree[next] -= 1
        if indegree[next] == 0:
            queue.append(next)

###################
###################
#다익스트라###########
###################
###################
# 최단거리알고리즘
# 시작점이있고 다른 모든 노드로 가는 최단거리를 구하는 알고리즘 *음수간선X
import sys
input = sys.stdin.readline
from queue import PriorityQueue

V, E = map(int, input().split())
K = int(input())
distance = [sys.maxsize] * (V + 1)
visited = [False] * (V + 1)
myList = [[] for _ in range(V + 1)]
q = PriorityQueue()

for _ in range(E):
    u, v, w = map(int, input().split())  # 가중치가 있는 인접 리스트 저장
    myList[u].append((v, w))

q.put((0, K))  # K를 시작점으로 설정
distance[K] = 0
while q.qsize() > 0:
    current = q.get()
    c_v = current[1]
    if visited[c_v]:
        continue
    visited[c_v] = True
    for tmp in myList[c_v]:
        next = tmp[0]
        value = tmp[1]
        if distance[next] > distance[c_v] + value:  # 최소 거리로 업데이트
            distance[next] = distance[c_v] + value
            q.put((distance[next], next))
for i in range(1, V + 1):
    if visited[i]:
        print(distance[i])
    else:
        print("INF")

###################
###################
#벨만포드###########
###################
###################
# 최단거리알고리즘
# 음수사이클있는지 체크하는 문제 ex) 시간여행, 웜홀 등등 *음수간선O
import sys
input = sys.stdin.readline
N, M = map(int, input().split())
edges = []
distance = [sys.maxsize]*(N+1)
for i in range(M):  # 에지 데이터 저장
    start, end, time = map(int, input().split())
    edges.append((start, end, time))

# 벨만포드 수행
distance[1] = 0
for _ in range(N-1):
    for start, end, time in edges:
        if distance[start] != sys.maxsize and distance[end] > distance[start] + time:
            distance[end] = distance[start] + time

# 음수 사이클 확인
mCycle = False
for start, end, time in edges:
    if distance[start] != sys.maxsize and distance[end] > distance[start] + time:
        mCycle = True

if not mCycle:
    for i in range(2, N+1):
        if distance[i] != sys.maxsize:
            print(distance[i])
        else:
            print(-1)
else:
    print(-1)

###################
###################
#플로이드워셜#######
###################
###################
# 최단거리알고리즘
# 시작점X, 시간복잡도 안좋음 , 모든도시를 연결하는 최단거리 (N이 작아야함)
import sys
input = sys.stdin.readline
N = int(input())
M = int(input())
distance = [[sys.maxsize for j in range(N+1)] for i in range(N+1)]
for i in range(1, N+1): # 인접 행렬 초기화
    distance[i][i] = 0

for i in range(M):
    s, e, v = map(int, input().split())
    if distance[s][e] > v:
        distance[s][e] = v

# 플로이드 워셜 수행
for k in range(1, N+1):
    for i in range(1, N+1):
        for j in range(1, N+1):
            if distance[i][j] > distance[i][k] + distance[k][j]:
                distance[i][j] = distance[i][k] + distance[k][j]

for i in range(1, N+1):
    for j in range(1, N+1):
        if distance[i][j] == sys.maxsize:
            print(0, end=' ')
        else:
            print(distance[i][j], end=' ')
    print()

###################
###################
#최소신장트리#######
###################
###################
# 모든 노드를 연결할때 사용된 에지들의 가중치의 합을 최소로 하는 트리
import sys
from queue import PriorityQueue

input = sys.stdin.readline
N, M = map(int, input().split())
pq = PriorityQueue()
parent = [0] * (N + 1)
for i in range(N + 1):
    parent[i] = i

for i in range(M):
    s, e, v = map(int, input().split())
    pq.put((v, s, e))  # 제일 앞 순서로 정렬되므로 가중치를 제일 앞 순서로 함

def find(a):
    if a == parent[a]:
        return a
    else:
        parent[a] = find(parent[a])
        return parent[a]

def union(a, b):
    a = find(a)
    b = find(b)
    if a != b:
        parent[b] = a

useEdge = 0
result = 0
while useEdge < N - 1:  # MST는 한상 N-1의 에지를 사용함
    v, s, e = pq.get()
    if find(s) != find(e):  # 같은 부모가 아닌 경우만 연결
        union(s, e)
        result += v
        useEdge += 1

print(result)


##################################################################################################################################
##################################################################################################################################
#순열#############################################################################################################################
##################################################################################################################################
##################################################################################################################################
from itertools import permutations
for i in permutations([1,2,3,4], 2):
    print(i, end=" ")

##################################################################################################################################
##################################################################################################################################
#조합#############################################################################################################################
##################################################################################################################################
##################################################################################################################################
from itertools import combinations
for i in combinations([1,2,3,4], 2):
    print(i, end=" ")

##################################################################################################################################
##################################################################################################################################
#try except#######################################################################################################################
##################################################################################################################################
##################################################################################################################################
try:
    st.pop()
except :
    return False
    